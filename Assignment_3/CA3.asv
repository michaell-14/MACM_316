% Part A) Newton 
syms x

F_sym = (x.*sin(pi.*x) + cos(pi.*x).*sin(pi.*x));
f1_sym = diff(F_sym, x);

iter_history = [];

F = matlabFunction(F_sym);
f1 = matlabFunction(f1_sym);
p0 = [0.77, 0.99];
tol = 1e-10; %tolerance for accuracy 
max_iter = 1000; %max iterations/break case

root = [0.78983, 1]; %found in part A
%newton method
for j = 1:length(p0)
    p_in = p0(j);
    error_start = 0; %intial approx of each index starts with no/unapplicable error
    for i = 1:max_iter

        %newtons approx.
        p1 = p_in - (F(p_in)./f1(p_in));

        error_pin = abs(p_in - root(j));
        error_p1 = abs(p1 - root(j));

        iter_history = [iter_history; i, p1, error_pin, error_p1, alpha, lambda]; 

        if abs(p1 - p_in) < tol
            break; %convergence met --> break loop
        end
        p_in = p1; %overwriting to continue next iteration
        error_start = error_p1;
    end 
    T = array2table(iter_history, 'VariableNames', {'Iteration', 'p_in', 'Error P_in', 'Error P1', 'Alpha', 'Lambda'});
    disp(T);
    disp(' ')
    disp(['For: ', num2str(p0(j)), ' Convergence reached at run: ', num2str(i)]);
    disp(['Convergence to: ', num2str(p1)])
end

% Part B) Convergence Analysis

%error ~= lambda*(error)^alpha 
%log(error_p1) ~= log(lambda*(error_pin^alpha))
%log(error_p1) ~= log(lambda) + alpha*log(error_pin)

%alpha = order of convergence, therefore can use power-law to find relation
%on log-log --> alpha = log
